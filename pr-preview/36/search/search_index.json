{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Kel-Circle","text":"<p>A synchronized multi-KEL circle protocol built on KERI.</p>"},{"location":"#from-keri-to-circles","title":"From KERI to circles","text":"<p>KERI gives each controller a sovereign Key Event Log (KEL) \u2014 an append-only, hash-chained, signed event sequence that establishes and evolves a self-certifying identifier. Inception creates the identifier; rotation replaces keys; interaction anchors arbitrary data. Each controller is fully autonomous: they can do whatever they want with their own KEL.</p> <p>This sovereignty is a feature for identity management, but a problem for group coordination. When multiple actors need to agree on shared state \u2014 membership, roles, proposals, votes \u2014 their independent KELs can evolve in any order. There is no canonical merge: the same set of events folded in different orders can produce different results.</p>"},{"location":"#the-synchronicity-problem","title":"The synchronicity problem","text":"<p>Consider a group of three admins voting on a proposal. Each admin appends an interaction event to their own KEL recording their vote. Without a shared ordering:</p> <ul> <li>Admin A sees votes A, B, C in that order</li> <li>Admin B sees votes B, A, C in a different order</li> <li>The fold result may differ depending on order</li> </ul> <p>Worse, there is no general way to detect conflicts or reconcile divergent folds while keeping all KELs meaningful. The KERI model of sovereign independence breaks down when actors need consensus on shared state.</p>"},{"location":"#the-kel-circle-solution","title":"The kel-circle solution","text":"<p>Kel-circle resolves this by separating two concerns:</p> <ol> <li> <p>Identity \u2014 each member keeps their own KEL for inception and    key rotation, exactly as KERI intends. Key management stays    sovereign.</p> </li> <li> <p>Coordination \u2014 a global sequence managed by a dedicated    server (the sequencer) provides canonical ordering for all    interaction events. Every interaction gets a unique index and a    strictly increasing UTC timestamp. No gaps, no reordering.</p> </li> </ol> <p>The sequencer is itself a circle member with its own KEL. It does not just relay events \u2014 it understands the full protocol semantics and enforces validity before assigning a sequence number.</p>"},{"location":"#closed-membership-and-access-control","title":"Closed membership and access control","text":"<p>A circle is not open. Membership is a base-layer concern, meaning the protocol itself (not the application) tracks who is in the circle and what roles they hold. The sequencer can always determine current members and admins by folding the event history.</p> <p>This gives the server the ability to enforce access control at the protocol level:</p> <ul> <li>Only members can submit events</li> <li>Only admins can propose membership changes</li> <li>Every submitted event passes a two-level gate:<ol> <li>Base gate \u2014 sequence number fresh, timestamp in bounds,    signer is a known member with appropriate role</li> <li>Application gate \u2014 event content valid per    application-specific semantics</li> </ol> </li> </ul> <p>The base gate is fixed by the protocol. The application gate is parameterized \u2014 different circles can enforce different domain rules while sharing the same coordination infrastructure.</p>"},{"location":"#architecture-overview","title":"Architecture overview","text":"<p>Five members \u2014 four regular (teal) and one sequencer (amber) \u2014 each maintain their own KEL. Inception events sit at the outer edge; newer events grow inward. Rose curves trace key rotations within a KEL. Numbered indigo arrows follow the global sequence across KELs: most interactions originate from members, but some (like timeout or threshold decisions) are emitted by the sequencer itself. All sequenced interaction events advance the fold. The fold is two-layered: a base fold (membership and roles, fixed by the protocol) and an application fold (domain-specific, pluggable).</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Base Semantics \u2014 membership, admin roles,   the two-level gate, and how the server controls access</li> <li>Event Classification \u2014 the three event   classes (decisions, proposals, responses) and the proposal   lifecycle</li> </ul>"},{"location":"architecture/","title":"Software Architecture","text":"<p>A deep analysis of kel-circle's structure, data flow, and key design patterns. Each section focuses on one architectural concern and includes a diagram.</p>"},{"location":"architecture/#package-layout","title":"Package layout","text":"<p>The project is a single Cabal package with two test suites and a companion PureScript client library.</p> <pre><code>graph TD\n    subgraph Haskell[\"Haskell \u2014 kel-circle.cabal\"]\n        LIB[\"library&lt;br/&gt;13 exposed modules\"]\n        SRV[\"executable&lt;br/&gt;kel-circle-server\"]\n        UT[\"test-suite&lt;br/&gt;unit-tests\"]\n        E2E[\"test-suite&lt;br/&gt;e2e-tests\"]\n        SRV --&gt; LIB\n        UT  --&gt; LIB\n        E2E --&gt; LIB\n    end\n\n    subgraph PS[\"PureScript \u2014 client/\"]\n        PSLIB[\"kel-circle-client&lt;br/&gt;API \u00b7 types \u00b7 codec \u00b7 fold\"]\n        PSAPP[\"kel-circle-trivial&lt;br/&gt;demo UI (Halogen)\"]\n        PSAPP --&gt; PSLIB\n    end\n\n    PSLIB -. \"mirrors logic\" .-&gt; LIB</code></pre>"},{"location":"architecture/#module-dependency-graph","title":"Module dependency graph","text":"<p>Arrows point from importer to importee. Foundation modules have no outgoing edges; the server sits at the top.</p> <pre><code>graph BT\n    Types\n    Events --&gt; Types\n    Sequence\n    State --&gt; Types &amp; Events\n    Fold --&gt; Sequence\n    Proposals --&gt; Types &amp; Events\n    Gate --&gt; Types &amp; Events &amp; State\n    Processing --&gt; Types &amp; Events &amp; Gate &amp; State &amp; Proposals\n    Validate --&gt; Types &amp; Events &amp; Processing\n    ServerJSON[\"Server.JSON\"] --&gt; Types &amp; Events &amp; State &amp; Proposals &amp; Validate\n    Store --&gt; Types &amp; Events &amp; Processing &amp; ServerJSON\n    Server --&gt; Types &amp; Events &amp; State &amp; Processing &amp; Validate &amp; ServerJSON &amp; Store</code></pre>"},{"location":"architecture/#core-type-hierarchy","title":"Core type hierarchy","text":"<pre><code>classDiagram\n    class MemberId {\n        +unMemberId : Text\n    }\n    class Role {\n        &lt;&lt;enumeration&gt;&gt;\n        Admin\n        Member\n    }\n    class Member {\n        +memberId : MemberId\n        +memberRole : Role\n        +memberName : Text\n    }\n    class CircleState {\n        +members : List Member\n    }\n    class Circle {\n        +circleState : CircleState\n        +sequencerId : MemberId\n    }\n    class AuthMode {\n        &lt;&lt;enumeration&gt;&gt;\n        Bootstrap\n        Normal\n    }\n    class FullState~g,p,r~ {\n        +fsCircle : Circle\n        +fsAppState : g\n        +fsProposals : ProposalRegistry~p,r~\n        +fsNextSeq : Int\n    }\n    class TrackedProposal~p,r~ {\n        +tpProposalId : ProposalId\n        +tpContent : p\n        +tpProposer : MemberId\n        +tpDeadline : Timestamp\n        +tpResponses : List r\n        +tpRespondents : List MemberId\n        +tpStatus : ProposalStatus\n    }\n    class ProposalStatus {\n        &lt;&lt;enumeration&gt;&gt;\n        Open\n        Resolved\n    }\n    class Resolution {\n        &lt;&lt;enumeration&gt;&gt;\n        ThresholdReached\n        ProposerPositive\n        ProposerNegative\n        Timeout\n    }\n\n    Member \"1\" --&gt; \"1\" MemberId\n    Member \"1\" --&gt; \"1\" Role\n    CircleState \"1\" o-- \"0..*\" Member\n    Circle \"1\" --&gt; \"1\" CircleState\n    Circle \"1\" --&gt; \"1\" MemberId : sequencerId\n    FullState \"1\" --&gt; \"1\" Circle\n    FullState \"1\" o-- \"0..*\" TrackedProposal\n    TrackedProposal \"1\" --&gt; \"1\" ProposalStatus\n    ProposalStatus --&gt; Resolution : when Resolved\n    AuthMode ..&gt; CircleState : derived from adminCount</code></pre>"},{"location":"architecture/#event-type-hierarchy","title":"Event type hierarchy","text":"<pre><code>classDiagram\n    class CircleEvent~d,p,r~ {\n        &lt;&lt;union&gt;&gt;\n        CEBaseDecision BaseDecision\n        CEAppDecision d\n        CEProposal p Timestamp\n        CEResponse r ProposalId\n        CEResolveProposal ProposalId Resolution\n    }\n    class BaseDecision {\n        &lt;&lt;union&gt;&gt;\n        IntroduceMember MemberId Text Role\n        RemoveMember MemberId\n        ChangeRole MemberId Role\n        RotateSequencer MemberId\n    }\n    class EventClass~d,p,r~ {\n        &lt;&lt;union&gt;&gt;\n        Decision d\n        Proposal p Timestamp MemberId\n        Response r ProposalId MemberId\n    }\n    class SequencedEvent~a~ {\n        +seqIndex : Int\n        +seqTimestamp : Timestamp\n        +seqMember : MemberId\n        +seqPayload : a\n    }\n\n    CircleEvent --&gt; BaseDecision : contains\n    SequencedEvent --&gt; CircleEvent : wraps\n    EventClass ..&gt; CircleEvent : classifies</code></pre>"},{"location":"architecture/#event-flow-submission-to-state-update","title":"Event flow: submission to state update","text":"<p>The path every event travels from the HTTP boundary to the updated in-memory state.</p> <pre><code>flowchart TD\n    CLIENT([Client]) --&gt;|\"POST /events&lt;br/&gt;JSON body\"| EP[\"/events endpoint\"]\n\n    EP --&gt; DEC{Decode JSON}\n    DEC --&gt;|fail| R400[\"400 Bad Request\"]\n    DEC --&gt;|ok| MODE{AuthMode?}\n\n    MODE --&gt;|Bootstrap| PP{\"Passphrase&lt;br/&gt;present &amp; correct?\"}\n    PP --&gt;|no| R401[\"401 Unauthorized\"]\n    PP --&gt;|yes| GATE\n\n    MODE --&gt;|Normal| GATE\n\n    GATE[\"Gate validation&lt;br/&gt;baseGate + appGate\"] --&gt; GR{Accept?}\n    GR --&gt;|no| R422[\"422 Unprocessable\"]\n    GR --&gt;|yes| SQL[(\"SQLite&lt;br/&gt;append row\")]\n\n    SQL --&gt; APPLY[\"Apply to FullState&lt;br/&gt;STM TVar update\"]\n    APPLY --&gt; BCAST[\"Broadcast via&lt;br/&gt;SSE channel\"]\n    APPLY --&gt; R200[\"200 OK&lt;br/&gt;{sequenceNumber: N}\"]\n\n    BCAST --&gt; SSE([SSE subscribers])</code></pre>"},{"location":"architecture/#two-level-gate-validation-pipeline","title":"Two-level gate validation pipeline","text":"<p>Every base-level decision passes through a chain of Boolean checks before it is accepted.</p> <pre><code>flowchart LR\n    D[BaseDecision] --&gt; PS{protectsSequencer?}\n    PS --&gt;|fail| REJ1[\"\u274c rejected\"]\n    PS --&gt;|pass| UN{hasUniqueName?}\n    UN --&gt;|fail| REJ2[\"\u274c rejected\"]\n    UN --&gt;|pass| BOOT{isBootstrap?}\n\n    BOOT --&gt;|yes| AI{\"IntroduceMember&lt;br/&gt;+ Admin?\"}\n    AI --&gt;|no| REJ3[\"\u274c rejected\"]\n    AI --&gt;|yes| ACC1[\"\u2705 accepted\"]\n\n    BOOT --&gt;|no| ADM{signer isAdmin?}\n    ADM --&gt;|no| REJ4[\"\u274c rejected\"]\n    ADM --&gt;|yes| MAJ{requiresMajority?}\n    MAJ --&gt;|yes| REJ5[\"\u274c rejected&lt;br/&gt;(needs proposal)\"]\n    MAJ --&gt;|no| APPG{\"appGate&lt;br/&gt;passes?\"}\n    APPG --&gt;|no| REJ6[\"\u274c rejected\"]\n    APPG --&gt;|yes| ACC2[\"\u2705 accepted\"]</code></pre> <p>Gates for other event types:</p> <pre><code>flowchart LR\n    subgraph AppDecision\n        AD[AppDecision] --&gt; ADM2{\"isMember&lt;br/&gt;signer?\"}\n        ADM2 --&gt;|no| R1[\"\u274c\"]\n        ADM2 --&gt;|yes| AG{appGate?}\n        AG --&gt;|no| R2[\"\u274c\"]\n        AG --&gt;|yes| A1[\"\u2705\"]\n    end\n\n    subgraph Response\n        RE[Response] --&gt; IM{\"isMember&lt;br/&gt;signer?\"}\n        IM --&gt;|no| R3[\"\u274c\"]\n        IM --&gt;|yes| PO{\"proposal&lt;br/&gt;open?\"}\n        PO --&gt;|no| R4[\"\u274c\"]\n        PO --&gt;|yes| HR{\"already&lt;br/&gt;responded?\"}\n        HR --&gt;|yes| R5[\"\u274c\"]\n        HR --&gt;|no| A2[\"\u2705\"]\n    end\n\n    subgraph Resolve\n        RV[Resolve] --&gt; IS{\"signer ==&lt;br/&gt;sequencerId?\"}\n        IS --&gt;|no| R6[\"\u274c\"]\n        IS --&gt;|yes| A3[\"\u2705\"]\n    end</code></pre>"},{"location":"architecture/#proposal-lifecycle-state-machine","title":"Proposal lifecycle state machine","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Open : CEProposal emitted&lt;br/&gt;by any member\n\n    Open --&gt; Open : CEResponse received&lt;br/&gt;(new respondent)\n\n    Open --&gt; Resolved_Threshold : CEResolveProposal&lt;br/&gt;(ThresholdReached)\n    Open --&gt; Resolved_PosProposer : CEResolveProposal&lt;br/&gt;(ProposerPositive)\n    Open --&gt; Resolved_NegProposer : CEResolveProposal&lt;br/&gt;(ProposerNegative)\n    Open --&gt; Resolved_Timeout : CEResolveProposal&lt;br/&gt;(Timeout)\n\n    Resolved_Threshold --&gt; [*]\n    Resolved_PosProposer --&gt; [*]\n    Resolved_NegProposer --&gt; [*]\n    Resolved_Timeout --&gt; [*]\n\n    note right of Open\n        Gate checks:\n        \u2022 signer is member\n        \u2022 proposal is open\n        \u2022 signer has not responded yet\n    end note\n\n    note right of Resolved_Threshold\n        Only the sequencer\n        can emit Resolve events\n    end note</code></pre>"},{"location":"architecture/#bootstrap-mode-lifecycle","title":"Bootstrap mode lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Bootstrap : server starts&lt;br/&gt;sequencer added&lt;br/&gt;(Member role, no admins)\n\n    Bootstrap --&gt; Bootstrap : passphrase-gated events&lt;br/&gt;(non-admin intros rejected)\n\n    Bootstrap --&gt; Normal : IntroduceMember _ Admin&lt;br/&gt;(first admin enters circle)\n\n    Normal --&gt; Normal : any base/app/proposal&lt;br/&gt;event under admin gate\n\n    Normal --&gt; Bootstrap : last admin demoted&lt;br/&gt;(adminCount \u2192 0)\n\n    note right of Bootstrap\n        Only IntroduceMember with\n        Admin role is permitted.\n        Passphrase required.\n    end note\n\n    note right of Normal\n        Admin signer required for\n        membership operations.\n        Proposals needed for role\n        changes requiring majority.\n    end note</code></pre>"},{"location":"architecture/#fold-and-replay-mechanism","title":"Fold and replay mechanism","text":"<p>The same fold function is used both on startup (full replay from SQLite) and on each new event (incremental update to the TVar).</p> <pre><code>flowchart TD\n    subgraph Startup\n        DB[(\"SQLite&lt;br/&gt;events table\")] --&gt;|SELECT all rows| ROWS[\"Ordered rows&lt;br/&gt;oldest \u2192 newest\"]\n        ROWS --&gt; FOLD[\"foldAll&lt;br/&gt;applyCircleEvent\"]\n        FOLD --&gt; FS0[Initial FullState]\n        FS0 --&gt; TV[(TVar FullState)]\n    end\n\n    subgraph OnNewEvent[\"On new event\"]\n        EV[New event] --&gt; VAL[Gate validation]\n        VAL --&gt; INS[INSERT INTO events]\n        INS --&gt; READ[Read current TVar]\n        READ --&gt; APP[applyCircleEvent]\n        APP --&gt; WRITE[\"Write TVar&lt;br/&gt;(STM atomic)\"]\n    end\n\n    subgraph Query\n        TV2[(TVar FullState)] --&gt;|readTVarIO| RESP[\"HTTP response&lt;br/&gt;or SSE\"]\n    end</code></pre> <p>The fold is parameterized \u2014 the same infrastructure handles both the fixed base fold and any pluggable application fold:</p> <pre><code>graph LR\n    subgraph twoLayerFold\n        BF[\"baseFold&lt;br/&gt;(membership, roles)\"]\n        AF[\"appFold&lt;br/&gt;(domain-specific g)\"]\n    end\n    SEQ[\"[SequencedEvent (CircleEvent d p r)]\"] --&gt; BF &amp; AF\n    BF --&gt; BS[\"CircleState (base)\"]\n    AF --&gt; AS[\"g (app state)\"]</code></pre>"},{"location":"architecture/#persistence-layer","title":"Persistence layer","text":"<pre><code>erDiagram\n    EVENTS {\n        int     id          PK\n        text    signer\n        text    event_json\n        text    signature\n    }</code></pre> <pre><code>flowchart LR\n    subgraph Store[\"CircleStore (runtime)\"]\n        TV[\"TVar FullState&lt;br/&gt;(hot cache)\"]\n        CONN[\"SQLite connection\"]\n    end\n\n    W[Write path] --&gt;|1 INSERT| CONN\n    CONN --&gt;|2 apply + atomically writeTVar| TV\n\n    R[Read path] --&gt;|readTVarIO| TV\n\n    CRASH([Server restart]) --&gt;|SELECT * replay| CONN\n    CONN --&gt;|full fold| TV</code></pre> <p>The hot TVar ensures O(1) reads; SQLite ensures durability across restarts without requiring a separate replay on every query.</p>"},{"location":"architecture/#server-http-interface","title":"Server HTTP interface","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant S as Server\n    participant DB as SQLite\n    participant CH as SSE channel\n\n    C-&gt;&gt;S: POST /events {signer,event,...}\n    S-&gt;&gt;S: decode + gate validation\n    alt rejected\n        S--&gt;&gt;C: 401 / 422\n    else accepted\n        S-&gt;&gt;DB: INSERT row\n        S-&gt;&gt;S: apply \u2192 TVar\n        S-&gt;&gt;CH: broadcast seqN\n        S--&gt;&gt;C: 200 {sequenceNumber: N}\n    end\n\n    C-&gt;&gt;S: GET /events?after=N\n    S-&gt;&gt;DB: SELECT row at N+1\n    alt exists\n        S--&gt;&gt;C: 200 {signer, event, signature}\n    else missing\n        S--&gt;&gt;C: 404\n    end\n\n    C-&gt;&gt;S: GET /stream\n    S--&gt;&gt;C: SSE text/event-stream\n    loop on each new event\n        CH-&gt;&gt;S: seqN\n        S--&gt;&gt;C: \"event: new data: {sn: N}\"\n    end</code></pre>"},{"location":"architecture/#client-sync-loop","title":"Client sync loop","text":"<p>The PureScript client never trusts state from the server directly \u2014 it re-derives state by replaying the event log from its last known checkpoint.</p> <pre><code>flowchart TD\n    START([App start]) --&gt; LOAD[\"Load checkpoint&lt;br/&gt;from localStorage\"]\n    LOAD --&gt; CONN[\"Connect to GET /stream&lt;br/&gt;SSE\"]\n\n    CONN --&gt; LISTEN{\"SSE event&lt;br/&gt;arrives?\"}\n    LISTEN --&gt;|yes: sn=N| CMP{N &gt; checkpoint?}\n    CMP --&gt;|no| LISTEN\n\n    CMP --&gt;|yes| FETCH[GET /events?after=checkpoint]\n    FETCH --&gt; MORE{more events?}\n    MORE --&gt;|yes| APPLY[\"applyCircleEvent&lt;br/&gt;through fold\"]\n    APPLY --&gt; INC[increment checkpoint]\n    INC --&gt; MORE\n    MORE --&gt;|no| SAVE[\"Save checkpoint&lt;br/&gt;to localStorage\"]\n    SAVE --&gt; LISTEN\n\n    USER([User action]) --&gt; SIGN[\"Sign event&lt;br/&gt;with private key\"]\n    SIGN --&gt; POST[POST /events]\n    POST --&gt; OK{200 OK?}\n    OK --&gt;|yes| INC2[update nextSeq]\n    OK --&gt;|no| ERR[Show error]</code></pre>"},{"location":"architecture/#serverclient-trust-boundary","title":"Server/client trust boundary","text":"<pre><code>graph LR\n    subgraph SRV[\"Server \u2014 authority\"]\n        SEQ[\"Sequencer identity\"] --&gt; ORD[\"Canonical ordering\"]\n        GATE[\"Gate enforcement\"] --&gt; ORD\n        ORD --&gt; DB[\"SQLite persistence\"]\n    end\n\n    subgraph CLI[\"Client \u2014 auditor\"]\n        KEY[\"Private key\"] --&gt;|signs| POST[\"POST /events\"]\n        FOLD[\"Fold replay\"] --&gt; CKPT[\"Local checkpoint\"]\n    end\n\n    SRV --&gt;|\"signed + ordered event stream\"| CLI\n    POST --&gt;|\"submit event\"| SRV</code></pre> Concern Server Client Canonical ordering \u2713 \u2717 (audits) Gate enforcement \u2713 (binding) \u2713 (UX hint) Private key \u2717 \u2713 State derivation fold + TVar fold + checkpoint Signature creation \u2717 \u2713 Signature verification \u2713 \u2713"},{"location":"architecture/#apply-functions-event-state-transition","title":"Apply functions: event \u2192 state transition","text":"<p>Each event type maps to exactly one apply function that touches a specific subset of <code>FullState</code>.</p> <pre><code>flowchart LR\n    subgraph FullState\n        C[fsCircle]\n        G[fsAppState]\n        P[fsProposals]\n        N[fsNextSeq]\n    end\n\n    BD[CEBaseDecision] --&gt;|applyBase| C &amp; N\n    AD[CEAppDecision] --&gt;|applyAppDecision| G &amp; N\n    PR[CEProposal] --&gt;|applyProposal| P &amp; N\n    RS[CEResponse] --&gt;|applyResponse| P &amp; N\n    RV[CEResolveProposal] --&gt;|applyResolve| P &amp; N</code></pre> <p><code>fsNextSeq</code> is incremented by every apply function \u2014 it is the monotonic sequence counter that clients use to detect new events.</p>"},{"location":"architecture/#admin-majority-voting","title":"Admin majority voting","text":"<p>Role changes requiring admin consensus use the proposal machinery with a <code>hasAdminMajority</code> threshold check.</p> <pre><code>sequenceDiagram\n    participant A as Admin A\n    participant S as Server\n    participant B as Admin B\n    participant C as Admin C\n\n    A-&gt;&gt;S: CEProposal (ChangeRole x Admin) deadline=T\n    S--&gt;&gt;A: sn=5\n\n    B-&gt;&gt;S: CEResponse vote sn=5\n    S--&gt;&gt;B: sn=6\n\n    C-&gt;&gt;S: CEResponse vote sn=5\n    S--&gt;&gt;C: sn=7\n\n    Note over S: adminCount=3, majority=2&lt;br/&gt;2 responses \u2265 2 \u2192 threshold met\n\n    S-&gt;&gt;S: CEResolveProposal 5 ThresholdReached\n    Note over S: sn=8, proposal resolved&lt;br/&gt;applyResolveWithEffect applies ChangeRole</code></pre> <p>The majority threshold is <code>adminCount / 2 + 1</code> \u2014 with one admin, that admin can act alone; with three admins, two are needed.</p> <p>Auto-resolution happens immediately after each <code>CEResponse</code>: the server checks <code>hasAdminMajority</code> on the updated respondent list and, if met, emits a <code>CEResolveProposal ThresholdReached</code> event signed by the sequencer. The <code>applyResolveWithEffect</code> function then applies the embedded <code>BaseDecision</code> to the circle state.</p>"},{"location":"architecture/#sequencer-rotation","title":"Sequencer rotation","text":"<p>When the sequencer role moves to a new member, the old sequencer's <code>memberName</code> is renamed to its <code>MemberId</code> string to preserve name uniqueness.</p> <pre><code>sequenceDiagram\n    participant Admin\n    participant Server\n\n    Note over Server: sequencerId = \"seq-0\"&lt;br/&gt;members = [{id:\"seq-0\",name:\"sequencer\",...}, ...]\n\n    Admin-&gt;&gt;Server: CEBaseDecision (RotateSequencer \"seq-1\")\n    Note over Server: rename \"seq-0\" member \u2192 name = \"seq-0\"&lt;br/&gt;prepend {id:\"seq-1\", name:\"sequencer\", role:Member}\n\n    Note over Server: sequencerId = \"seq-1\"&lt;br/&gt;members = [{id:\"seq-1\",name:\"sequencer\"}, {id:\"seq-0\",name:\"seq-0\"}, ...]</code></pre>"},{"location":"architecture/#testing-strategy","title":"Testing strategy","text":"<pre><code>graph TD\n    subgraph Unit[\"unit-tests\"]\n        GEN[\"Generators&lt;br/&gt;arbitrary MemberId / Role\"]\n        SEQ2[\"Sequence&lt;br/&gt;invariants\"]\n        BD2[\"BaseDecisions&lt;br/&gt;membership ops\"]\n        GT[\"Gate&lt;br/&gt;two-level checks\"]\n        PR2[\"Proposals&lt;br/&gt;lifecycle\"]\n        PR3[\"Processing&lt;br/&gt;state transitions\"]\n    end\n\n    subgraph E2E2[\"e2e-tests\"]\n        HTTP[\"Real HTTP server&lt;br/&gt;on random port\"]\n        SC[Bootstrap scenario]\n        MM[Member management]\n        RL[Role change proposals]\n        RB[Re-bootstrap]\n        REP[Event replay]\n    end\n\n    subgraph Lean[\"Lean 4 (formalization)\"]\n        INV[Invariants]\n        THM[Theorems]\n    end\n\n    GEN --&gt; SEQ2 &amp; BD2 &amp; GT &amp; PR2 &amp; PR3\n    Lean -. \"mirrored by\" .-&gt; Unit\n    Unit -. \"composed into\" .-&gt; E2E2</code></pre> <p>Properties are named to mirror Lean theorems: <code>bootstrap_accepts_admin_intro</code>, <code>full_gate_base_rejects</code>, <code>resolution_dichotomy</code>, etc., making the correspondence between the formal proof and the executable tests explicit.</p>"},{"location":"base-semantics/","title":"Base Semantics","text":"<p>The base semantics are the protocol-level rules that the sequencer enforces independently of any application. They give the server the ability to control access and maintain circle integrity.</p>"},{"location":"base-semantics/#global-sequence","title":"Global sequence","text":"<p>The sequencer maintains a monotonic counter starting at zero. Each accepted interaction event is assigned the next index.</p> <p>Invariant 1 \u2014 no gaps, no duplicates. Every index from 0 to the current counter is populated by exactly one interaction event.</p> <p>Invariant 2 \u2014 strictly increasing timestamps. Each index carries a UTC timestamp. For any indices i &lt; j, the timestamp at i is strictly less than the timestamp at j.</p> <p>Invariant 3 \u2014 server semantic authority. The sequencer has full knowledge of the protocol and application semantics. It governs what interactions are valid and controls the fold.</p> <p>Lean predicates: <code>SequencedEvent</code>, <code>GlobalSequence</code>, <code>WellFormedSequence</code>, <code>indicesContiguous</code>, <code>timestampsIncreasing</code>, <code>noDuplicateIndices</code>, <code>append_preserves_contiguous</code>, <code>append_preserves_increasing</code>, <code>append_preserves_no_dups</code></p>"},{"location":"base-semantics/#circle-genesis","title":"Circle genesis","text":"<p>The first two events in every circle are fixed by the protocol:</p> <p>Event 0 \u2014 sequencer self-introduction. The sequencer introduces itself as a non-admin member. This is a hard-coded genesis event, not subject to any gate. The sequencer needs to be a member so it can sign events (e.g. decisions that resolve proposals), but it is never an admin.</p> <p>Event 1 \u2014 first admin introduction. The first human user introduces themselves as an admin. This happens during bootstrap mode (no admins exist yet), gated by a passphrase challenge. After this event, normal mode begins.</p>"},{"location":"base-semantics/#sequencer-protection","title":"Sequencer protection","text":"<p>The sequencer is a permanent, non-admin member:</p> <ul> <li>Cannot be removed \u2014 the base gate rejects any <code>removeMember</code>   targeting the sequencer</li> <li>Cannot be promoted to admin \u2014 the base gate rejects any   <code>changeRole</code> promoting the sequencer to admin</li> </ul> <p>These protections are enforced unconditionally, regardless of mode.</p> <p>The sequencer's identity can be replaced via a sequencer rotation \u2014 any admin can do this as a straight decision.</p> <p>Lean predicates: <code>genesis</code>, <code>genesis_sequencer_is_member</code>, <code>genesis_sequencer_not_admin</code>, <code>genesis_is_bootstrap</code>, <code>genesis_preserves_sequencer_id</code>, <code>sequencer_removal_rejected</code>, <code>sequencer_admin_promotion_rejected</code></p>"},{"location":"base-semantics/#membership","title":"Membership","text":"<p>Membership is a base-layer concern. The protocol itself tracks who is in the circle. The sequencer can always determine the current member set by folding the event history \u2014 no application logic required.</p> <p>A member is identified by their KERI prefix (the self-certifying identifier from their own KEL). Each member's KEL is independent and handles inception and key rotation per the KERI specification.</p> <p>Lean predicates: <code>CircleState</code>, <code>isMember</code>, <code>isAdmin</code>, <code>admin_is_member</code></p>"},{"location":"base-semantics/#admin-roles","title":"Admin roles","text":"<p>Admin is a distinguished base-layer role. Admins can:</p> <ul> <li>Introduce new members (straight decision)</li> <li>Propose admin promotions and demotions (requires majority)</li> <li>Remove members (straight decision)</li> </ul> <p>Non-admin members can participate in application-level interactions but cannot modify the circle's membership structure.</p>"},{"location":"base-semantics/#base-decisions","title":"Base decisions","text":"<p>The protocol defines two categories of membership operations:</p>"},{"location":"base-semantics/#straight-decisions-admin-gated","title":"Straight decisions (admin-gated)","text":"<p>These are accepted immediately when the signer is an admin:</p> <ul> <li>Introduce member \u2014 add a new non-admin member to the circle.   Introducing someone directly as admin is rejected by the straight   gate \u2014 admin role requires a majority proposal.</li> <li>Remove member \u2014 remove a member from the circle. Removing the   sequencer is always rejected. The application gate also   participates: it can reject a removal based on domain state   (e.g. a member with frozen funds in an open order cannot be   removed until the order resolves).</li> <li>Rotate sequencer \u2014 replace the sequencer's identity with a   new KERI prefix. The old sequencer stays as a regular member;   the new one takes over sequencing.</li> </ul>"},{"location":"base-semantics/#proposals-requiring-admin-majority","title":"Proposals requiring admin majority","text":"<p>These require a proposal with majority approval from all current admins:</p> <ul> <li>Promote to admin \u2014 change a member's role to admin</li> <li>Demote from admin \u2014 change an admin's role to member</li> </ul> <p>Admin role changes affect the power structure of the circle, so they require consensus rather than unilateral action. Note that a single remaining admin can demote themselves (majority of one), which returns the circle to bootstrap mode.</p> <p>Lean predicates: <code>BaseDecision</code>, <code>applyBaseDecision</code>, <code>Circle</code>, <code>introduce_adds_member</code>, <code>introduce_admin_exits_bootstrap</code>, <code>introduce_preserves_existing</code>, <code>baseGate</code>, <code>rotate_accepted_by_admin</code>, <code>rotate_new_sequencer_is_member</code>, <code>rotate_old_sequencer_stays_member</code>, <code>rotate_updates_sequencer_id</code>, <code>majority</code>, <code>hasAdminMajority</code>, <code>single_admin_majority</code>, <code>demote_sole_admin_enters_bootstrap</code>, <code>demote_then_bootstrap_accepts_admin</code>, <code>sequencer_survives_demotion</code></p>"},{"location":"base-semantics/#the-two-level-gate","title":"The two-level gate","text":"<p>Every event submitted to the sequencer must pass two gates before it is accepted and assigned a sequence number.</p>"},{"location":"base-semantics/#level-1-base-gate","title":"Level 1: base gate","text":"<p>The base gate is fixed by the protocol. It checks:</p> <ol> <li> <p>Sequencer protection \u2014 the event does not remove or promote    the sequencer</p> </li> <li> <p>Mode-dependent authorization:</p> <ul> <li>Bootstrap mode \u2014 only <code>introduceMember</code> with admin role is   accepted (passphrase-gated)</li> <li>Normal mode \u2014 signer must be an admin for membership   operations; signer must be a member for application events</li> </ul> </li> <li> <p>Sequence number freshness \u2014 the submitter's claimed sequence    number must still be available. If another event was already    assigned that index, the submission is rejected. This detects    stale state (the submitter was looking at an old fold).</p> </li> <li> <p>Timestamp bounds \u2014 the submitted timestamp must be within a    configured accuracy window of the server's clock. This prevents    backdated or far-future events.</p> </li> <li> <p>Membership \u2014 the signer must be a known member of the    circle. The signer is identified by verifying the Ed25519    signature against the public key from their KEL.</p> </li> </ol>"},{"location":"base-semantics/#level-2-application-gate","title":"Level 2: application gate","text":"<p>The application gate is parameterized. Different circles supply different validation functions. In general, the application gate can see both the base fold state and the application fold state. However, for base decisions (membership operations), only the application fold state is needed \u2014 the base gate already handles all membership and role checks:</p> <pre><code>applicationGate :: AppFoldState -&gt; BaseDecision -&gt; Bool\n</code></pre> <p>The sequencer applies this function after the base gate passes. If the application gate rejects the event, it is not sequenced.</p> <p>The application gate sees all events, including base decisions like member removal. This allows the application to block removals when domain invariants would be violated (e.g. a member with active commitments cannot be removed until those commitments are resolved).</p> <p>This separation means the base infrastructure (membership, roles, sequencing, proposals) is reusable across applications, while each application defines its own domain-specific validity rules.</p> <p>Lean predicates: <code>protectsSequencer</code>, <code>requiresMajority</code>, <code>baseGate</code>, <code>fullGate</code>, <code>full_gate_base_rejects</code>, <code>full_gate_app_rejects</code></p>"},{"location":"base-semantics/#bootstrap-mode","title":"Bootstrap mode","text":"<p>When the circle has zero admins, it is in bootstrap mode. The genesis sequence is:</p> <ol> <li>Event 0 \u2014 sequencer self-introduces as member (no gate)</li> <li>Still in bootstrap \u2014 sequencer is not an admin</li> <li>Event 1 \u2014 first user self-introduces as admin (passphrase-gated)</li> <li>Normal mode begins</li> </ol>"},{"location":"base-semantics/#re-entering-bootstrap","title":"Re-entering bootstrap","text":"<p>If the last admin demotes themselves (via a majority proposal \u2014 which trivially passes with one admin), the circle returns to bootstrap mode. The sequencer remains as a permanent non-admin member (event 0 is never undone). A new admin can then self-introduce using the passphrase, exactly as during initial setup.</p> <p>This means the circle is never stuck: as long as someone knows the passphrase, the admin role can always be recovered.</p> <p>Lean predicates: <code>isBootstrap</code>, <code>isBootstrapB</code>, <code>empty_is_bootstrap</code>, <code>genesis_is_bootstrap</code>, <code>bootstrap_accepts_admin_intro</code>, <code>bootstrap_rejects_member_intro</code>, <code>bootstrap_rejects_remove</code></p>"},{"location":"base-semantics/#fold-computation","title":"Fold computation","text":"<p>The circle's current state is computed by folding all events in the global sequence. Every sequenced interaction event \u2014 decision, proposal, or response \u2014 contributes to the fold.</p> <p>The fold has two layers:</p> <ul> <li> <p>Base fold \u2014 extracts membership and role information. This   layer is fixed by the protocol. The base gate uses only the base   fold to check membership, roles, and freshness.</p> </li> <li> <p>Application fold \u2014 accumulates domain-specific state. This   layer is pluggable. The application gate uses the full fold   (base + application) to validate domain rules.</p> </li> </ul> <p>To compute the current state:</p> <ol> <li>Walk the global sequence from index 0</li> <li>Apply each event to the fold accumulator (both base and    application layers)</li> </ol> <p>A future optimization may allow skipping fully resolved proposals during fold replay, but the base model treats every sequenced event as a fold input.</p>"},{"location":"base-semantics/#event-processing-pipeline","title":"Event processing pipeline","text":"<p>The sequencer processes five kinds of events, each with its own gate and state transition:</p> <ol> <li> <p>Base decision \u2014 membership operations (introduce, remove,    changeRole, rotate). Gated by the two-level gate (<code>baseGate</code> +    application gate). Updates the circle state.</p> </li> <li> <p>Application decision \u2014 domain-specific straight decisions.    Signer must be a member. Application gate validates content.    Updates the application fold state only.</p> </li> <li> <p>Proposal \u2014 opens a coordination round. Signer must be a    member. Registers the proposal in the proposal registry with    its deadline.</p> </li> <li> <p>Response \u2014 responds to an open proposal. Signer must be a    member who has not already responded to this proposal. The    proposal must be open.</p> </li> <li> <p>Proposal resolution \u2014 server-emitted decision that closes    a proposal. Only the sequencer can emit resolutions.</p> </li> </ol> <p>Each event increments the global sequence number. The processing pipeline guarantees separation of concerns:</p> <ul> <li>Base decisions change the circle but not the proposal registry</li> <li>Application decisions change the app fold but not the circle   or the proposal registry</li> <li>Proposals and responses change the proposal registry but not   the circle or the app fold</li> <li>Resolutions change the proposal registry but not the circle   or the app fold</li> </ul> <p>This separation is formally verified in Lean: each <code>apply*</code> function preserves the state components it does not logically modify.</p>"},{"location":"base-semantics/#resolve-with-effect","title":"Resolve with effect","text":"<p>When a proposal carries a <code>BaseDecision</code> (via the <code>extractDecision</code> callback), positive resolution triggers that decision on the circle. This is the mechanism that enables majority-gated operations like role changes and admin introductions through the proposal flow.</p> <p>The function <code>applyResolveWithEffect</code> extends <code>applyResolve</code>:</p> <ol> <li>Close the proposal (same as <code>applyResolve</code>)</li> <li>If the resolution is positive (<code>ThresholdReached</code> or    <code>ProposerPositive</code>), look up the proposal content</li> <li>Extract a <code>BaseDecision</code> from the content</li> <li>Apply that decision to the circle</li> </ol> <p>The sequencer auto-resolves proposals after each response when admin majority is detected. This avoids a separate resolution step from the client.</p> <p>Lean predicates: <code>applyResolveWithEffect</code>, <code>applyResolveWithEffect_increments_seq</code>, <code>applyResolveWithEffect_negative_eq</code>, <code>applyResolveWithEffect_preserves_proposals</code></p> <p>Lean predicates: <code>CircleEvent</code>, <code>FullState</code>, <code>initFullState</code>, <code>gateBaseDecision</code>, <code>gateAppDecision</code>, <code>gateProposal</code>, <code>gateResponse</code>, <code>gateResolve</code>, <code>applyBase</code>, <code>applyAppDecision</code>, <code>applyProposal</code>, <code>applyResponse</code>, <code>applyResolve</code>, <code>apply_base_increments_seq</code>, <code>apply_app_decision_increments_seq</code>, <code>apply_proposal_increments_seq</code>, <code>apply_response_increments_seq</code>, <code>apply_resolve_increments_seq</code>, <code>app_decision_preserves_circle</code>, <code>proposal_preserves_circle</code>, <code>response_preserves_circle</code>, <code>resolve_preserves_circle</code>, <code>base_preserves_proposals</code>, <code>app_decision_preserves_proposals</code>, <code>non_sequencer_cannot_resolve</code>, <code>sequencer_can_resolve</code>, <code>init_seq_is_one</code>, <code>init_no_proposals</code>, <code>init_sequencer_is_member</code></p>"},{"location":"base-semantics/#dependency-on-full-kels","title":"Dependency on full KELs","text":"<p>Both the server and clients must fold and validate against the full KELs of all circle members \u2014 not just the interaction events in the global sequence. Each member's KEL includes inception, key rotation, and interaction events per the KERI specification.</p> <p>When the server receives a new event, it resolves the signer's KEL to verify the signature against their current key state. Only then does it apply the two-level gate and (if accepted) assign a sequence number. Clients perform the same verification when replaying the global sequence.</p> <p>Without access to the full KELs, neither server nor client can confirm that a signature is valid under the signer's current public key (which may have been rotated since the event was signed). The global sequence provides canonical ordering; the KELs provide cryptographic identity.</p>"},{"location":"base-semantics/#server-vs-client-asymmetric-roles","title":"Server vs client: asymmetric roles","text":"<p>Both server and clients fold the global sequence and validate against full KELs, but their roles are fundamentally asymmetric.</p>"},{"location":"base-semantics/#server-gatekeeper","title":"Server: gatekeeper","text":"<p>The server is always online and maintains the source of truth for all member KELs. It holds copies of every member's full KEL (inception, key rotations, interactions) so it can resolve key state and verify signatures at any time without depending on external infrastructure.</p> <p>Members cannot update their own KELs directly. Every KEL event \u2014 inception, key rotation, and interaction \u2014 must be submitted to the server. The server validates each event (correct prior digest, valid signature) and only then appends it to its copy of that member's KEL. The server is the sole writer of all KELs in the circle.</p> <p>For each submitted event, the server:</p> <ol> <li>Resolves the signer's KEL and verifies the signature</li> <li>Challenges membership \u2014 confirms the signer is a known    member of the circle (from the current base fold)</li> <li>Applies the base gate \u2014 sequencer protection, mode-dependent    authorization, sequence freshness, timestamp bounds</li> <li>Applies the application gate \u2014 domain-specific validation</li> <li>If all gates pass, assigns the next sequence number</li> </ol> <p>The membership challenge is critical: it happens before any other gate logic. An event from an unknown signer is rejected immediately, regardless of its content.</p> <p>The server is also responsible for relaying all data to clients. Clients do not communicate with each other \u2014 they receive the global sequence and all member KELs exclusively from the server. This makes the server the single point of distribution for all circle state.</p>"},{"location":"base-semantics/#client-auditor","title":"Client: auditor","text":"<p>Clients replay the global sequence after events have been accepted and sequenced. They:</p> <ol> <li>Obtain the global sequence and all member KELs</li> <li>For each event, verify the signature against the signer's KEL</li> <li>Recompute both folds (base + application) over all events</li> <li>Confirm the resulting state matches the server's reported state</li> </ol> <p>Clients do not re-run the gate logic \u2014 the server already enforced it. Instead, they verify that the server's decisions were consistent: every sequenced event has a valid signature from a member who was in the circle at the time. If the server accepted an event from a non-member, the client's replay would detect the inconsistency.</p> <p>Clients store the current fold state locally \u2014 this is public data derived from the global sequence and requires no special protection. The member's private key is stored separately and protected by a password. The two are never co-located: the fold state can be freely cached and synced, while the private key remains locked until the user authenticates to sign a new event.</p>"},{"location":"base-semantics/#checkpoint-based-sync","title":"Checkpoint-based sync","text":"<p>For efficiency, clients do not replay the full history from genesis on every connection. Instead, they maintain a checkpoint \u2014 a snapshot of the fold state (both base and application layers) at a known sequence index, together with the pre-image of that fold: the complete circle of KELs as they stood at that index. The fold state is derived from the KELs, so storing the pre-image alongside the result lets the client resume verification from a known-good point without replaying from genesis.</p> <p>To stay current, clients connect to an SSE (Server-Sent Events) endpoint. The SSE stream continuously provides:</p> <ul> <li>The next free sequence number (tip of the global sequence)</li> <li>The current server time</li> <li>Notifications when new events are sequenced</li> </ul> <p>The sequence number and time allow clients to detect when they are behind and to construct valid submissions (with a fresh sequence number and timestamp within the accuracy window). On receiving a notification of new events, the client requests the delta from its checkpoint index to the current tip \u2014 all new events and KEL updates since the checkpoint. The client applies the delta to its local state, advancing to the tip.</p> <p>This is analogous to blockchain light sync: the client trusts its own checkpoint (which it previously verified) and only replays the new events. A full replay from genesis is always possible for complete re-verification but is not required for normal operation.</p>"},{"location":"base-semantics/#trust-model-censor-but-not-forge","title":"Trust model: censor but not forge","text":"<p>The server has full visibility over all events and full control over what gets sequenced \u2014 it can delay, reorder, or reject submissions. In this sense, the server is a censor.</p> <p>However, the server cannot forge events. Every event carries a signature from the member's private key, and the server never holds any member's private key. A forged event would fail signature verification during client replay. This is the fundamental security guarantee: the server controls the sequence, but cannot fabricate the content.</p>"},{"location":"event-classification/","title":"Event Classification","text":"<p>The global sequence contains events of three classes. The classes are fixed by the protocol; the content within each class is parameterized by the application.</p>"},{"location":"event-classification/#the-three-event-classes","title":"The three event classes","text":""},{"location":"event-classification/#1-straight-decision","title":"1. Straight decision","text":"<p>A straight decision is an event that, as long as it passes both the base gate and the application gate, is accepted and immediately changes the fold state. No coordination machinery is involved \u2014 no proposal, no voting, no timeout.</p> <p>The two-level gate for straight decisions:</p> <pre><code>baseGate        :: CircleState -&gt; MemberId -&gt; MemberId -&gt; BaseDecision -&gt; Bool\napplicationGate :: AppFoldState -&gt; BaseDecision -&gt; Bool\n</code></pre> <p>If both gates return true, the decision is sequenced and the fold advances. If either returns false, the event is rejected.</p> <p>Straight decisions are the simplest path: a member submits, the server validates through the two-level gate, the fold updates.</p>"},{"location":"event-classification/#2-proposal","title":"2. Proposal","text":"<p>A proposal is an event that initiates a coordination round. It contributes to the fold like any other sequenced event, and also opens a window for responses that eventually resolves into a decision (positive or negative).</p> <p>A proposal carries:</p> <ul> <li> <p>Mandatory timeout \u2014 bounded by the server's configured   maximum. If no positive resolution occurs before the timeout,   the sequencer emits a negative decision automatically.</p> </li> <li> <p>Optional threshold gate \u2014 a function over collected   responses:</p> <pre><code>thresholdGate :: [ResponseContent] -&gt; Bool\n</code></pre> <p>When the threshold is met, the sequencer emits a positive decision automatically.</p> </li> </ul>"},{"location":"event-classification/#3-response","title":"3. Response","text":"<p>A response is an event submitted by a member in reaction to an open proposal. Its content is application-defined \u2014 the protocol does not prescribe what a response looks like, only that it references a specific proposal.</p> <p>Responses contribute to the fold like any other sequenced event. They also accumulate for lifecycle tracking until:</p> <ul> <li>The threshold gate fires (if present), or</li> <li>The proposer closes the proposal, or</li> <li>The timeout expires</li> </ul> <p>Lean predicates: <code>EventClass</code>, <code>event_trichotomy</code>, <code>decision_not_proposal</code>, <code>decision_not_response</code>, <code>proposal_not_response</code>, <code>Resolution</code>, <code>ProposalStatus</code>, <code>TrackedProposal</code>, <code>ProposalRegistry</code></p>"},{"location":"event-classification/#proposal-lifecycle","title":"Proposal lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Open: member submits proposal\n    Open --&gt; Resolved: threshold reached\n    Open --&gt; Resolved: proposer closes positively\n    Open --&gt; Resolved: proposer closes negatively\n    Open --&gt; Expired: timeout reached\n    Resolved --&gt; [*]: server emits decision\n    Expired --&gt; [*]: server emits negative decision</code></pre>"},{"location":"event-classification/#opening","title":"Opening","text":"<p>A member submits a proposal event. The sequencer validates it (base gate + application gate), assigns a sequence number, and records it as open with its timeout deadline.</p>"},{"location":"event-classification/#collecting-responses","title":"Collecting responses","text":"<p>Members submit response events referencing the proposal. Each response is sequenced and associated with the open proposal.</p>"},{"location":"event-classification/#resolution","title":"Resolution","text":"<p>A proposal resolves in one of four ways:</p> <ol> <li> <p>Threshold reached \u2014 if the proposal has a threshold gate and    enough valid responses accumulate to satisfy it, the sequencer    emits a positive decision. The decision carries the responses    that satisfied the threshold.</p> </li> <li> <p>Proposer closes positively \u2014 the original proposer can close    their proposal at any time with a positive outcome. They must    include a subset of the collected responses. The sequencer emits    a decision carrying those responses.</p> </li> <li> <p>Proposer closes negatively \u2014 the proposer cancels the    proposal. The sequencer emits a negative decision.</p> </li> <li> <p>Timeout \u2014 the deadline passes without resolution. The    sequencer emits a negative decision automatically. This is    guaranteed because the timeout is mandatory.</p> </li> </ol>"},{"location":"event-classification/#server-emitted-decisions","title":"Server-emitted decisions","text":"<p>In cases 1, 3, and 4, the sequencer itself emits the decision event. This is why the server is a circle member with its own KEL \u2014 it signs these decision events with its own key.</p> <p>The server-emitted decision is a regular event in the global sequence. Clients can verify its signature against the server's KEL just like any other event.</p>"},{"location":"event-classification/#response-validation","title":"Response validation","text":"<p>A member can respond to an open proposal at most once. The protocol tracks respondents per proposal and rejects duplicate responses. Only open proposals accept responses \u2014 once resolved, no further responses are accepted.</p>"},{"location":"event-classification/#timeout-obligation","title":"Timeout obligation","text":"<p>Every proposal has a mandatory deadline. The sequencer must resolve any open proposal whose deadline has passed. This is a liveness obligation on the sequencer: as long as the sequencer is running, no proposal remains open past its deadline. Resolved proposals trivially satisfy this obligation.</p>"},{"location":"event-classification/#admin-majority-as-a-threshold-gate","title":"Admin majority as a threshold gate","text":"<p>Admin role changes (promote/demote) use the proposal mechanism with admin majority as the threshold gate. The threshold checks whether the number of admin respondents meets the majority threshold for the current circle. A single admin trivially meets majority with their own response, which is why a lone admin can demote themselves.</p> <p>Lean predicates: <code>openProposal</code>, <code>addResponse</code>, <code>resolveProposal</code>, <code>findProposal</code>, <code>open_proposal_is_open</code>, <code>open_proposal_no_responses</code>, <code>resolve_resolved_noop</code>, <code>resolution_dichotomy</code>, <code>threshold_is_positive</code>, <code>proposer_positive_is_positive</code>, <code>proposer_negative_is_negative</code>, <code>timeout_is_negative</code>, <code>timeoutObligation</code>, <code>resolved_satisfies_obligation</code>, <code>adminMajorityMet</code>, <code>single_admin_majority_self</code>, <code>hasNotResponded</code>, <code>canRespond</code>, <code>fresh_proposal_accepts_response</code></p>"},{"location":"event-classification/#all-event-classes-contribute-to-the-fold","title":"All event classes contribute to the fold","text":"<p>All three event classes \u2014 decisions, proposals, and responses \u2014 advance the fold state when sequenced. The fold has two layers:</p> <ul> <li> <p>Base fold \u2014 extracts membership and role information from all   event types. This layer is fixed by the protocol. The base gate   uses only the base fold to check membership, roles, and freshness.</p> </li> <li> <p>Application fold \u2014 accumulates domain-specific state from all   event types. This layer is pluggable. The application gate uses   the full fold (base + application) to validate domain rules.</p> </li> </ul> <p>The event classification still matters for the proposal lifecycle (proposals open coordination rounds, responses accumulate within them, decisions resolve them) but all three classes feed into the fold. A future optimization may allow skipping fully resolved proposals during fold replay, but the base model treats every sequenced event as a fold input.</p> <p>This means:</p> <ul> <li>No separate L1/L2 event logs</li> <li>One global sequence for everything</li> <li>Every sequenced event advances the fold</li> <li>Full audit trail preserved in the sequence</li> </ul> <p>Lean predicates: <code>foldAll</code>, <code>fold_empty</code>, <code>fold_append</code>, <code>TwoLayerState</code>, <code>twoLayerFold</code>, <code>two_layer_fold_empty</code>, <code>two_layer_fold_append</code></p>"},{"location":"event-classification/#application-parameterization","title":"Application parameterization","text":"<p>The protocol fixes the event classes (decision, proposal, response) but leaves the content to the application:</p> Aspect Protocol (fixed) Application (parameterized) Event classes decision, proposal, response \u2014 Membership base-layer, extracted from fold \u2014 Admin roles base-layer \u2014 Decision content \u2014 domain-specific payload Proposal content timeout, threshold gate shape domain-specific payload Response content \u2014 domain-specific payload Base gate membership, freshness, sequencer protection \u2014 Application gate \u2014 domain-specific validation Threshold gate \u2014 application-defined function <p>The application supplies:</p> <ul> <li>Types for decision, proposal, and response content</li> <li>An application gate function (for base decisions:   <code>AppFoldState -&gt; BaseDecision -&gt; Bool</code>)</li> <li>An optional threshold gate function per proposal   (<code>[ResponseContent] -&gt; Bool</code>)</li> <li>A fold function that applies events to state</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#phase-1-foundation","title":"Phase 1 \u2014 Foundation \u2705","text":"<p>Core protocol semantics, Lean formalisation, and a running server.</p> <ul> <li>Global sequence invariants (contiguity, monotone timestamps, no duplicates)</li> <li>Two-level gate: fixed base gate + pluggable application gate</li> <li>Full membership lifecycle: introduce, remove, change role</li> <li>Proposal machinery: open, respond, resolve (manual)</li> <li>Sequencer protection and rotation</li> <li>Unique member-name invariant</li> <li>SQLite persistence with full-replay on restart</li> <li>HTTP + SSE server (WAI)</li> <li>KERI AID for the sequencer (Ed25519 keypair, CESR prefix, storage invariant)</li> <li>PureScript client library mirroring Haskell semantics</li> <li>50+ QuickCheck properties, 15+ E2E scenarios</li> <li>Lean formalisation of invariants and gate theorems</li> </ul>"},{"location":"roadmap/#phase-2-cryptographic-integrity","title":"Phase 2 \u2014 Cryptographic integrity","text":"<p>Signatures are currently persisted but never verified. Every submitted event carries an Ed25519 signature over the payload, but the gate layer ignores it. This phase closes that gap and brings members' identities in line with KERI.</p>"},{"location":"roadmap/#current-state","title":"Current state","text":"Component Status <code>Submission</code> carries <code>subSigner :: Text</code> and <code>subSignature :: Text</code> \u2705 stored SQLite <code>events</code> table has <code>signer</code> and <code>signature</code> columns \u2705 stored <code>MemberId</code> is a <code>Text</code> newtype \u2014 no format validation \u274c unvalidated <code>signSubmission</code> in E2E helpers produces dummy <code>\"sig:&lt;key&gt;\"</code> \u274c not real crypto No <code>keri-hs</code> dependency in <code>kel-circle.cabal</code> \u274c missing No signature verification anywhere in gate or server \u274c missing No challenge-response endpoints \u274c missing PureScript client has no Ed25519 keygen or signing \u274c missing"},{"location":"roadmap/#sub-roadmap","title":"Sub-roadmap","text":"<p>Phase 2 is split into six incremental steps. Each step is independently buildable and testable; later steps depend on earlier ones.</p>"},{"location":"roadmap/#step-21-add-keri-hs-dependency-and-cesr-validation","title":"Step 2.1 \u2014 Add <code>keri-hs</code> dependency and CESR validation","text":"<p>Wire the <code>keri-hs</code> library into kel-circle. Use it to validate that <code>MemberId</code> values are well-formed CESR-encoded Ed25519 public key prefixes.</p> <p>Changes:</p> <ul> <li>Add <code>keri-hs</code> to <code>kel-circle.cabal</code> <code>build-depends</code> (and to the Nix   flake input if needed)</li> <li>New module <code>KelCircle.Crypto</code> that re-exports the subset of <code>keri-hs</code>   needed: <code>Keri.Cesr.decode</code>, <code>Keri.Cesr.Primitive</code>,   <code>Keri.Cesr.DerivationCode(Ed25519PubKey, Ed25519Sig)</code>,   <code>Keri.Crypto.Ed25519.verify</code>, <code>Keri.Crypto.Ed25519.publicKeyFromBytes</code></li> <li>Validation function <code>validateCesrPrefix :: Text -&gt; Either Text PublicKey</code>   that decodes a CESR text, checks the derivation code is <code>Ed25519PubKey</code>,   and returns the parsed public key</li> <li><code>IntroduceMember mid name role</code> \u2014 the gate rejects if <code>mid</code> is not a   valid CESR Ed25519 prefix (call <code>validateCesrPrefix</code>)</li> <li>Add <code>InvalidMemberId</code> constructor to <code>ValidationError</code></li> <li>E2E test: scenario 6 (non-CESR member ID rejected)</li> </ul> <p>Done when: existing tests still pass, and introducing a member with a garbage <code>MemberId</code> returns 422.</p>"},{"location":"roadmap/#step-22-signature-verification-at-the-gate-layer","title":"Step 2.2 \u2014 Signature verification at the gate layer","text":"<p>Every <code>POST /events</code> must carry a valid Ed25519 signature over the JSON-serialized event body, verifiable against the signer's public key.</p> <p>Changes:</p> <ul> <li>New function <code>verifySubmissionSignature :: Text -&gt; Text -&gt; LBS.ByteString   -&gt; Either Text ()</code> \u2014 decodes the CESR signer prefix to a public key,   decodes the CESR signature, and calls <code>Keri.Crypto.Ed25519.verify</code></li> <li>What is signed: the canonical JSON encoding of <code>subEvent</code> (the same   bytes the server stores in <code>event_json</code>). The server re-encodes the event   to JSON and verifies the signature over those bytes.</li> <li>Call <code>verifySubmissionSignature</code> in <code>handlePostEvent</code> (and   <code>handleBootstrapPost</code>) before gate validation. Return 422 with a new   <code>SignatureInvalid</code> error on failure.</li> <li>Add <code>SignatureInvalid</code> constructor to <code>ValidationError</code> (or a separate   <code>CryptoError</code> type)</li> <li>Update E2E <code>TestId</code> to hold a real <code>Keri.Crypto.Ed25519.KeyPair</code>;   <code>newTestId</code> calls <code>generateKeyPair</code>, <code>tidKey</code> becomes the CESR-encoded   public key prefix</li> <li>Update <code>signSubmission</code> to produce a real Ed25519 signature over the   JSON-encoded event</li> <li>E2E tests: scenarios 1\u20134 (valid accepted, forged rejected, wrong-key   rejected, tampered payload rejected)</li> </ul> <p>Done when: all 4 signature E2E scenarios pass, existing E2E tests still pass (they now use real signatures).</p>"},{"location":"roadmap/#step-23-anchored-key-verification-for-members","title":"Step 2.3 \u2014 Anchored key verification for members","text":"<p>After introduction, all subsequent events from a member must be signed with the key that was anchored at introduction time.</p> <p>Changes:</p> <ul> <li><code>Member</code> gains a <code>memberKey :: Text</code> field (the CESR-encoded public key,   already stored as the second argument to <code>IntroduceMember</code>)</li> <li>On <code>POST /events</code> in normal mode, look up the signer's <code>memberKey</code> from   <code>CircleState.members</code> and verify the signature against that key (not   just against the <code>subSigner</code> text \u2014 the signer must match an anchored   member)</li> <li>Reject if <code>subSigner</code> does not match any member's <code>memberKey</code>, or if the   signature doesn't verify against the anchored key</li> <li>In bootstrap mode the signer is the new admin being introduced, so the   key is self-certifying: the <code>subSigner</code> text is the key, and the   signature is verified against it</li> <li>E2E tests: scenarios 5, 7 (introduction anchors key; subsequent events   verified against anchored key)</li> </ul> <p>Done when: a member introduced with key A cannot submit events signed with key B.</p>"},{"location":"roadmap/#step-24-challenge-response-authentication","title":"Step 2.4 \u2014 Challenge-response authentication","text":"<p>Prevent impersonation by requiring clients to prove possession of their private key before submitting events.</p> <p>Changes:</p> <ul> <li>New server-side state: <code>TVar (Map MemberId ByteString)</code> for pending   nonces, <code>TVar (Map Text MemberId)</code> for session tokens</li> <li>New endpoint <code>GET /challenge?member=&lt;memberId&gt;</code> \u2014 generate a random   32-byte nonce, store it keyed by member ID, return <code>{\"nonce\": \"&lt;hex&gt;\"}</code></li> <li>New endpoint <code>POST /challenge</code> \u2014 body   <code>{\"member\": \"&lt;memberId&gt;\", \"signedNonce\": \"&lt;CESR sig&gt;\"}</code>. Server looks up   the pending nonce, verifies the signature against the member's anchored   key, and on success: deletes the nonce (one-time use), generates a random   session token, stores it in the session map, returns   <code>{\"token\": \"&lt;token&gt;\"}</code></li> <li><code>POST /events</code> requires an <code>Authorization: Bearer &lt;token&gt;</code> header in   normal mode. Server looks up the token to find the signer's member ID.   The <code>subSigner</code> field must match the token's member ID.</li> <li>Bootstrap mode is exempt from challenge-response (no members exist yet   to challenge)</li> <li>Nonces expire after a configurable TTL (e.g. 60 seconds)</li> <li>E2E tests: scenarios 8\u201312 (challenge issued, correct response accepted,   wrong-key rejected, replayed nonce rejected, unauthenticated POST   rejected)</li> </ul> <p>Done when: all 5 challenge-response E2E scenarios pass.</p>"},{"location":"roadmap/#step-25-purescript-client-crypto","title":"Step 2.5 \u2014 PureScript client crypto","text":"<p>Browser-side Ed25519 key generation, signing, and challenge-response flow.</p> <p>Changes:</p> <ul> <li>PureScript FFI module wrapping the Web Crypto API (or a JS Ed25519   library like <code>@noble/ed25519</code>) for: key generation, signing, CESR   encoding of public key and signature</li> <li>Key storage in browser <code>localStorage</code>, encrypted with a user-chosen   passphrase (AES-GCM via Web Crypto)</li> <li>Client codec updated: <code>encodeSubmission</code> takes a <code>KeyPair</code> and signs the   JSON-serialized event before encoding</li> <li>Challenge-response flow in the client: on connect, call   <code>GET /challenge?member=&lt;myId&gt;</code>, sign the nonce, <code>POST /challenge</code>, store   the session token, attach it to subsequent <code>POST /events</code> requests</li> <li>Halogen UI: key generation on first use, passphrase prompt, visual   indicator of authentication state</li> </ul> <p>Done when: the Halogen demo can bootstrap an admin, introduce members, and submit events \u2014 all with real Ed25519 signatures and challenge-response auth.</p>"},{"location":"roadmap/#step-26-sequencer-ordering-e2e-and-cross-cutting-invariants","title":"Step 2.6 \u2014 Sequencer ordering E2E and cross-cutting invariants","text":"<p>Final verification pass: sequencer ordering properties and cross-cutting invariants that must hold across all scenarios.</p> <p>Changes:</p> <ul> <li>E2E tests: scenarios 13\u201316 (contiguous sequence numbers, monotonically   increasing, monotonic timestamps, no duplicates)</li> <li>Cross-cutting invariant tests (run after every multi-event scenario):<ul> <li>Replay the full log via <code>GET /events</code> and verify every signature   against the signer's anchored public key</li> <li>Verify the sequencer's events are signed with the sequencer's KERI   AID key</li> <li>Verify no two members share the same public key prefix</li> <li>Verify global sequence invariants (contiguity, monotonicity, no   duplicates)</li> </ul> </li> </ul> <p>Done when: all 16 scenarios pass, all cross-cutting invariants hold, CI is green.</p>"},{"location":"roadmap/#security-e2e-scenarios-summary","title":"Security E2E scenarios (summary)","text":"# Category Scenario Expected 1 Signature Valid signature accepted 200 2 Signature Forged signature rejected 422 3 Signature Wrong-key signature rejected 422 4 Signature Tampered payload rejected 422 5 AID anchoring Introduction anchors public key key in /condition 6 AID anchoring Non-CESR member ID rejected 422 7 AID anchoring Subsequent events verified against anchored key 200 / 422 8 Challenge Challenge issued on connect nonce returned 9 Challenge Correct challenge response accepted 200 + token 10 Challenge Wrong-key challenge rejected 401 11 Challenge Replayed nonce rejected 401 12 Challenge Unauthenticated POST rejected 401 13 Ordering Sequence numbers are contiguous verified 14 Ordering Sequence numbers are monotonically increasing verified 15 Ordering Timestamps are monotonically non-decreasing verified 16 Ordering No duplicate sequence numbers verified"},{"location":"roadmap/#cross-cutting-invariants","title":"Cross-cutting invariants","text":"<ul> <li>Every event in the log has a valid signature verifiable against the   signer's anchored public key.</li> <li>The sequencer's events are signed with the sequencer's KERI AID key.</li> <li>No two members share the same public key prefix.</li> <li>The event log satisfies global sequence invariants: contiguous,   monotonically increasing sequence numbers; monotonically non-decreasing   timestamps; no duplicate sequence numbers.</li> </ul>"},{"location":"roadmap/#phase-3-protocol-completeness","title":"Phase 3 \u2014 Protocol completeness","text":"<p>Features that the semantics document already specifies but the implementation does not yet enforce.</p> <ul> <li>Automatic proposal resolution \u2014 the sequencer emits a   <code>CEResolveProposal</code> event automatically when the admin-majority threshold   is reached, or when the deadline passes (timeout)</li> <li>Sequencer rotation with key migration \u2014 <code>RotateSequencer</code> must carry   the new sequencer's public key; both the old and new sequencer sign the   rotation event</li> <li>Freshness check \u2014 submitted events must reference a recent sequence   number; stale events are rejected</li> </ul>"},{"location":"roadmap/#phase-4-application-layer-and-production-readiness","title":"Phase 4 \u2014 Application layer and production readiness","text":"<p>The library's polymorphic <code>(d, p, r)</code> layer is currently exercised only with <code>Unit</code> types. This phase demonstrates and hardens real usage.</p> <ul> <li>Reference application \u2014 a concrete <code>(d, p, r)</code> instantiation with a   non-trivial decision type, serving as documentation and integration test</li> <li>Client UI \u2014 extend the Halogen demo to cover the full member lifecycle   (join, vote, rotate)</li> <li>Deployment guide and Nix service module</li> <li>Hackage publication \u2014 <code>cabal check</code>, bounds, changelog, <code>cabal sdist</code></li> </ul>"}]}